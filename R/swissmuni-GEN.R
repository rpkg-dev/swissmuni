# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/swissmuni.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literature programming approach used applying the R Markdown format.

utils::globalVariables(names = ".")

.onLoad <- function(libname, pkgname) {
  pkgpins::clear(pkg = pkgname,
                 max_age = getOption("swissmuni.max_cache_lifespan",
                                     default = "30 days"))
}

.onUnload <- function(libpath) {
  pkgpins::deregister(pkg = pkg)
}

pkg <- utils::packageName()

# URLs/paths common to all API endpoints
api_base_url <- "https://sms.bfs.admin.ch/"
api_common_path <- "WcfBFSSpecificService.svc/AnonymousRest/communes/"

# Unicode copy/paste symbol
cp_symbol <- "\u2398"

as_api_date <- function(date) {
  
  lubridate::ymd(date) %>%
    checkmate::assert_date(any.missing = FALSE,
                           null.ok = TRUE,
                           .var.name = "start/end_date") %>%
    purrr::when(length(.) == 0L ~ NULL,
                ~ format(., "%d-%m-%Y"))
}

#' Get allowed API URL parameters
#'
#' @param type The API endpoint.
#'
#' @return A [tibble][tibble::tbl_df].
#' @keywords internal
#'
#' @examples
#' # to get all URL params of all 3 API endpoints:
#' library(magrittr)
#'
#' endpoints <- c("snapshots",
#'                "congruences",
#'                "mutations",
#'                "classifications")
#'
#' \donttest{
#' endpoints %>%
#'   purrr::map(getFromNamespace("api_params",
#'                               ns = "swissmuni")) %>%
#'   rlang::set_names(nm = endpoints)}
api_params <- function(type = c("snapshots",
                                "congruences",
                                "mutations",
                                "classifications")) {
  
  rlang::arg_match(type) %>%
    switch("snapshots" = "GetSnapshot",
           "congruences" = "GetCorrespondances",
           "mutations" = "GetMutations",
           "classifications" = "GetGeographicLevel") %>%
    paste0("//xs:element[@name='", ., "']") %>%
    xml2::xml_find_all(x = xml2::read_xml("https://sms.bfs.admin.ch/WcfBFSSpecificService.svc?singleWsdl")) %>%
    checkmate::assert_list(len = 1L,
                           types = "xml_node",
                           any.missing = FALSE) %>%
    xml2::xml_find_all(xpath = ".//xs:element") %>%
    xml2::xml_attrs() %>%
    purrr::map(as.list) %>%
    purrr::map_dfr(tibble::as_tibble)
}

parse_result <- function(response,
                         col_types) {
  
  response %<>% httr::content(as = "text")
  
  response %>% readr::read_csv(col_types = pal::cols_regex("(Name|_Title|_Text|^ABBREV)" = readr::col_character(),
                                                           "^(MutationDate|ValidFrom|ValidTo)$" = readr::col_date(format = "%d.%m.%Y"),
                                                           .col_names = pal::dsv_colnames(response),
                                                           .default = readr::col_integer()))
}

#' Get municipality snapshots
#'
#' This function returns a [tibble][tibble::tbl_df] with snapshots of Swiss municipality data. A snapshot is the state of the municipalities at a specified
#' point in time. Therefore you probably want to leave the default `end_date = start_date`.
#'
#' @includeRmd snippets/fso_vs_historicized_code.Rmd
#'
#' @param start_date The begin of the period the data covers. A [date](base::Date) or a character scalar in the format `"YYYY-MM-DD"`.
#' @param end_date The end of the period the data covers. A [date](base::Date) or a character scalar in the format `"YYYY-MM-DD"`.
#' @param historicized_code By default, the [_FSO commune number_](https://de.wikipedia.org/wiki/Gemeindenummer) is returned. Set to `TRUE` in order to get the
#'   _historicization number_ instead.
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")` Defaults to 1 day (24 hours).
#'
#' @return `r pkgsnip::return_label("data")`
#' @export
#'
#' @examples
#' snapshots(historicized_code = TRUE)
snapshots <- function(start_date = lubridate::today(),
                      end_date = start_date,
                      historicized_code = FALSE,
                      use_cache = TRUE,
                      cache_lifespan = "1 day") {
  
  if (checkmate::assert_flag(use_cache)) {
    
    pin_name <- pkgpins::call_to_name()
    result <- pkgpins::get_obj(id = pin_name,
                               max_age = cache_lifespan,
                               pkg = pkg)
    fetch <- is.null(result)
    
  } else {
    fetch <- TRUE
  }
  
  if (fetch) {
    
    result <-
      httr::GET(url = api_base_url,
                path = paste0(api_common_path, "snapshots"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             useBfsCode = tolower(checkmate::assert_flag(historicized_code)))) %>%
      parse_result()
  }
  
  if (use_cache & fetch) {
    
    pkgpins::cache_obj(x = result,
                       id = pin_name,
                       pkg = pkg)
  }
  
  result
}

#' Get municipality congruences
#'
#' This function returns a [tibble][tibble::tbl_df] with congruence data of Swiss municipalities.
#'
#' @inheritParams snapshots
#' @param incl_unmodified Include municipalities where no changes occurred in the defined period.
#' @param incl_territory_exchange Include information (additional rows) about territory exchanges within and between municipalities.
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' congruences(start_date = lubridate::today(),
#'             end_date = lubridate::today(),
#'             cache_lifespan = "6 hours")
congruences <- function(start_date = NULL,
                        end_date = NULL,
                        incl_unmodified = TRUE,
                        incl_territory_exchange = FALSE,
                        use_cache = TRUE,
                        cache_lifespan = "1 day") {
  
  if (checkmate::assert_flag(use_cache)) {
    
    pin_name <- pkgpins::call_to_name()
    result <- pkgpins::get_obj(id = pin_name,
                               max_age = cache_lifespan,
                               pkg = pkg)
    fetch <- is.null(result)
    
  } else {
    fetch <- TRUE
  }
  
  if (fetch) {
    
    result <-
      httr::GET(url = api_base_url,
                path = paste0(api_common_path, "correspondances"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             includeUnmodified = tolower(checkmate::assert_flag(incl_unmodified)),
                             includeTerritoryExchange = tolower(checkmate::assert_flag(incl_territory_exchange)))) %>%
      parse_result()
  }
  
  if (use_cache & fetch) {
    
    pkgpins::cache_obj(x = result,
                       id = pin_name,
                       pkg = pkg)
  }
  
  result
}

#' Get municipality mutations
#'
#' This function returns a [tibble][tibble::tbl_df] with mutation data of Swiss municipalities.
#'
#' @inheritParams snapshots
#' @inheritParams congruences
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' mutations(start_date = "2020-01-01",
#'           end_date = "2020-06-30",
#'           incl_territory_exchange = TRUE)
mutations <- function(start_date = NULL,
                      end_date = NULL,
                      incl_territory_exchange = FALSE,
                      use_cache = TRUE,
                      cache_lifespan = "1 day") {
  
  if (checkmate::assert_flag(use_cache)) {
    
    pin_name <- pkgpins::call_to_name()
    result <- pkgpins::get_obj(id = pin_name,
                               max_age = cache_lifespan,
                               pkg = pkg)
    fetch <- is.null(result)
    
  } else {
    fetch <- TRUE
  }
  
  if (fetch) {
    
    result <-
      httr::GET(url = api_base_url,
                path = paste0(api_common_path, "mutations"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             includeTerritoryExchange = tolower(checkmate::assert_flag(incl_territory_exchange)))) %>%
      parse_result()
  }
  
  if (use_cache & fetch) {
    
    pkgpins::cache_obj(x = result,
                       id = pin_name,
                       pkg = pkg)
  }
  
  result
}

#' Get geographical classifications of municipalities
#'
#' This function returns a [tibble][tibble::tbl_df] with a wide range of geographical classifications of Swiss municipalities.
#'
#' There are some classifications which have multiple column IDs (e.g. `HR_ARBREG2000_L2` and `HR_TYPMSR2000_L2` both contain the _spatial mobility regions_).
#' If `name_type` is set to a language code, column duplicates are given the name suffix "`r paste0(' (', cp_symbol, ')')`".
#'
#' @includeRmd snippets/fso_vs_historicized_code.Rmd
#'
#' @inheritParams snapshots
#' @param name_type The column name type to be returned. Defaults to the column IDs returned by the web service. If set to a language code, the columns
#'   starting with ID `HR_` will be named by its full label in the respective language instead.
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' classifications(start_date = lubridate::today(),
#'                 end_date = lubridate::today(),
#'                 name_type = "de",
#'                 use_cache = FALSE)
classifications <- function(start_date = NULL,
                            end_date = NULL,
                            historicized_code = FALSE,
                            name_type = c("ID", "en", "de", "fr", "it"),
                            use_cache = TRUE,
                            cache_lifespan = "1 day") {
  
  if (checkmate::assert_flag(use_cache)) {
    
    pin_name <- pkgpins::call_to_name(exclude_args = c("name_type",
                                                       "use_cache",
                                                       "cache_lifespan"))
    result <- pkgpins::get_obj(id = pin_name,
                               max_age = cache_lifespan,
                               pkg = pkg)
    fetch <- is.null(result)
    
  } else {
    fetch <- TRUE
  }
  
  if (fetch) {
    
    result <-
      httr::GET(url = api_base_url,
                path = paste0(api_common_path, "levels"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             useBfsCode = tolower(checkmate::assert_flag(historicized_code)))) %>%
      parse_result()
  }
  
  if (use_cache & fetch) {
    
    pkgpins::cache_obj(x = result,
                       id = pin_name,
                       pkg = pkg)
  }
  
  name_type <- rlang::arg_match(name_type)
  
  if (name_type != "ID") {
    
    hr_ix <- which(stringr::str_detect(colnames(result), "^HR_"))
    hr_ids <- colnames(result) %>% stringr::str_subset("^HR_")
    hr_names <- col_spec_classifications[[paste0("name_", name_type)]][match(hr_ids, col_spec_classifications$column_id)]
    
    # ensure column names are unique (there are different column IDs for the same values)
    # -> add the unicode symbol for copy/paste, multiple times if necessary
    while (anyDuplicated(hr_names)) {
      hr_names[which(duplicated(hr_names))] <- paste0(hr_names[which(duplicated(hr_names))], " ", cp_symbol)
    }
    
    colnames(result)[hr_ix] <- hr_names
  }
  
  result
}
