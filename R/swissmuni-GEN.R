# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/swissmuni.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#literate-programming` for more information on the literature programming approach used applying the R Markdown format.

utils::globalVariables(names = ".")

.onLoad <- function(libname, pkgname) {
  pkgpins::clear(pkg = pkgname)
}

.onUnload <- function(libpath) {
  pkgpins::deregister(pkg = pkg)
}

pkg <- utils::packageName()

# URLs/paths common to all API endpoints
api_base_url <- "https://sms.bfs.admin.ch/"
api_common_path <- "WcfBFSSpecificService.svc/AnonymousRest/communes/"

# WSDL XML
api_wsdl <- xml2::read_xml("https://sms.bfs.admin.ch/WcfBFSSpecificService.svc?singleWsdl")

as_api_date <- function(date) {
  
  lubridate::ymd(date) %>%
    checkmate::assert_date(any.missing = FALSE,
                           null.ok = TRUE,
                           .var.name = "start/end_date") %>%
    purrr::when(length(.) == 0L ~ NULL,
                ~ format(., "%d-%m-%Y"))
}

#' Get allowed API URL parameters
#'
#' @param type The API endpoint.
#'
#' @return A [tibble][tibble::tbl_df].
#' @keywords internal
#'
#' @examples
#' # to get all params for all 3 API endpoints:
#' library(magrittr)
#'
#' endpoints <- c("snapshots",
#'                "congruences",
#'                "mutations",
#'                "classifications")
#'
#' \dontrun{
#' endpoints %>%
#'   purrr::map(api_params) %>%
#'   rlang::set_names(nm = endpoints)}
api_params <- function(type = c("snapshots",
                                "congruences",
                                "mutations",
                                "classifications")) {
  
  rlang::arg_match(type) %>%
    switch("snapshots" = "GetSnapshot",
           "congruences" = "GetCorrespondances",
           "mutations" = "GetMutations",
           "classifications" = "GetGeographicLevel") %>%
    paste0("//xs:element[@name='", ., "']") %>%
    xml2::xml_find_all(x = api_wsdl) %>%
    checkmate::assert_list(len = 1L,
                           types = "xml_node",
                           any.missing = FALSE) %>%
    xml2::xml_find_all(xpath = ".//xs:element") %>%
    xml2::xml_attrs() %>%
    purrr::map(as.list) %>%
    purrr::map_dfr(tibble::as_tibble)
}

parse_result <- function(response,
                         col_types) {
  
  response %<>% httr::content(as = "text")
  
  response %>% readr::read_csv(col_types = pal::cols_regex("(Name|_Title|_Text|^ABBREV)" = readr::col_character(),
                                                           "^(MutationDate|ValidFrom|ValidTo)$" = readr::col_date(format = "%d.%m.%Y"),
                                                           .col_names = pal::dsv_colnames(response),
                                                           .default = readr::col_integer()))
}

#' Get municipality snapshots
#'
#' This function returns a [tibble][tibble::tbl_df] with snapshots of Swiss municipality data. A snapshot is the state of the municipalities at a specified
#' point in time. Therefore you probably want to set `start_date = end_date`.
#'
#' @includeRmd snippets/fso_vs_historicized_code.Rmd
#'
#' @param start_date The begin of the period the data covers. A [date](base::Date) or a character scalar in the format `"YYYY-MM-DD"`.
#' @param end_date The end of the period the data covers. A [date](base::Date) or a character scalar in the format `"YYYY-MM-DD"`.
#' @param historicized_code By default, the [_FSO commune number_](https://de.wikipedia.org/wiki/Gemeindenummer) is returned. Set to `TRUE` in order to get the
#'   _historicization number_ instead.
#' @param use_cache `r pkgsnippets::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnippets::param_label("cache_lifespan")` Defaults to 1 day (24 hours).
#'
#' @return `r pkgsnippets::return_label("data")`
#' @export
#'
#' @examples
#' snapshots(start_date = "2020-01-01",
#'           end_date = "2020-01-01",
#'           use_cache = FALSE)
snapshots <- function(start_date = lubridate::today() - 1L,
                      end_date = start_date,
                      historicized_code = FALSE,
                      use_cache = TRUE,
                      cache_lifespan = "1 day") {
  
  if (checkmate::assert_flag(use_cache)) {
    
    pin_name <- pkgpins::call_to_name()
    result <- pkgpins::get_obj(id = pin_name,
                               max_age = cache_lifespan,
                               pkg = pkg)
    fetch <- is.null(result)
    
  } else {
    fetch <- TRUE
  }
  
  if (fetch) {
    
    result <-
      httr::GET(url = api_base_url,
                path = paste0(api_common_path, "snapshots"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             useBfsCode = tolower(historicized_code))) %>%
      parse_result()
  }
  
  if (use_cache) {
    
    pkgpins::cache_obj(x = result,
                       id = pin_name,
                       pkg = pkg)
  }
  
  result
}

#' Get municipality congruences
#'
#' This function returns a [tibble][tibble::tbl_df] with congruence data of Swiss municipalities.
#'
#' @inheritParams snapshots
#' @param incl_unmodified Include municipalities where no changes occurred in the defined period.
#' @param incl_territory_exchange Include information about territory exchanges between municipalities.
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' congruences(start_date = "2010-01-01",
#'             end_date = Sys.Date(),
#'             cache_lifespan = "6 hours")
congruences <- function(start_date = NULL,
                        end_date = NULL,
                        incl_unmodified = TRUE,
                        incl_territory_exchange = FALSE,
                        use_cache = TRUE,
                        cache_lifespan = "1 day") {
  
  if (checkmate::assert_flag(use_cache)) {
    
    pin_name <- pkgpins::call_to_name()
    result <- pkgpins::get_obj(id = pin_name,
                               max_age = cache_lifespan,
                               pkg = pkg)
    fetch <- is.null(result)
    
  } else {
    fetch <- TRUE
  }
  
  if (fetch) {
    
    result <-
      httr::GET(url = api_base_url,
                path = paste0(api_common_path, "correspondances"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             includeUnmodified = tolower(incl_unmodified),
                             includeTerritoryExchange = tolower(incl_territory_exchange))) %>%
      parse_result()
  }
  
  if (use_cache) {
    
    pkgpins::cache_obj(x = result,
                       id = pin_name,
                       pkg = pkg)
  }
  
  result
}

#' Get municipality mutations
#'
#' This function returns a [tibble][tibble::tbl_df] with mutation data of Swiss municipalities.
#'
#' @inheritParams snapshots
#' @inheritParams congruences
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' mutations(start_date = "2020-01-01",
#'           end_date = "2020-06-01")
mutations <- function(start_date = NULL,
                      end_date = NULL,
                      incl_territory_exchange = FALSE,
                      use_cache = TRUE,
                      cache_lifespan = "1 day") {
  
  if (checkmate::assert_flag(use_cache)) {
    
    pin_name <- pkgpins::call_to_name()
    result <- pkgpins::get_obj(id = pin_name,
                               max_age = cache_lifespan,
                               pkg = pkg)
    fetch <- is.null(result)
    
  } else {
    fetch <- TRUE
  }
  
  if (fetch) {
    
    result <-
      httr::GET(url = api_base_url,
                path = paste0(api_common_path, "mutations"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             includeTerritoryExchange = tolower(incl_territory_exchange))) %>%
      parse_result()
  }
  
  if (use_cache) {
    
    pkgpins::cache_obj(x = result,
                       id = pin_name,
                       pkg = pkg)
  }
  
  result
}

#' Get geographical classifications of municipalities
#'
#' This function returns a [tibble][tibble::tbl_df] with a wide range of geographical classifications of Swiss municipalities.
#'
#' @includeRmd snippets/fso_vs_historicized_code.Rmd
#'
#' @inheritParams snapshots
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' classifications(historicized_code = TRUE,
#'                 cache_lifespan = "1 week")
classifications <- function(start_date = NULL,
                            end_date = NULL,
                            historicized_code = FALSE,
                            use_cache = TRUE,
                            cache_lifespan = "1 day") {
  
  if (checkmate::assert_flag(use_cache)) {
    
    pin_name <- pkgpins::call_to_name()
    result <- pkgpins::get_obj(id = pin_name,
                               max_age = cache_lifespan,
                               pkg = pkg)
    fetch <- is.null(result)
    
  } else {
    fetch <- TRUE
  }
  
  if (fetch) {
    
    result <-
      httr::GET(url = api_base_url,
                path = paste0(api_common_path, "levels"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             useBfsCode = tolower(historicized_code))) %>%
      parse_result()
  }
  
  if (use_cache) {
    
    pkgpins::cache_obj(x = result,
                       id = pin_name,
                       pkg = pkg)
  }
  
  result
}
