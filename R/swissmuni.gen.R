# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/swissmuni.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# swissmuni: Download Municipality Data from the Swiss Federal Statistical Office's Web Services
# Copyright (C) 2023 Salim Brüggemann
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

utils::globalVariables(names = ".")

.onLoad <- function(libname, pkgname) {
  
  # clear pkgpins cache
  tryCatch(expr = pkgpins::clear_cache(board = pkgpins::board(pkg = pkgname),
                                       max_age = pal::pkg_config_val(key = "global_max_cache_age",
                                                                     pkg = pkgname)),
           error = function(e) cli::cli_alert_warning(text = "Failed to clear pkgpins cache on load of {.pkg {pkgname}}. Error message: {e$message}"))
}

this_pkg <- utils::packageName()

# URLs/paths common to all API endpoints
api_base_url <- "https://sms.bfs.admin.ch/"
api_common_path <- "WcfBFSSpecificService.svc/AnonymousRest/communes/"

# Unicode copy/paste symbol
cp_symbol <- "\u2398"

as_api_date <- function(date) {
  
  lubridate::ymd(date) %>%
    checkmate::assert_date(any.missing = FALSE,
                           null.ok = TRUE,
                           .var.name = "start/end_date") %>%
    pal::when(length(.) == 0L ~ NULL,
              ~ format(., "%d-%m-%Y"))
}

#' Get allowed API URL parameters
#' 
#' Parses the API's [Web Services Description Language (WSDL)](https://en.wikipedia.org/wiki/Web_Services_Description_Language) file to determine
#' possible URL parameters.
#'
#' @param type The API endpoint.
#'
#' @return A [tibble][tibble::tbl_df].
#' @keywords internal
#' @export
#'
#' @examples
#' # get all URL params of all 3 API endpoints:
#' endpoints <- c("snapshots",
#'                "congruences",
#'                "mutations",
#'                "classifications")
#'
#' endpoints |>
#'   purrr::map(swissmuni::api_params) |>
#'   rlang::set_names(nm = endpoints)
api_params <- function(type = c("snapshots",
                                "congruences",
                                "mutations",
                                "classifications")) {
  rlang::check_installed("xml2",
                         reason = pal::reason_pkg_required())
  
  rlang::arg_match(type) %>%
    switch("snapshots" = "GetSnapshot",
           "congruences" = "GetCorrespondances",
           "mutations" = "GetMutations",
           "classifications" = "GetGeographicLevel") %>%
    paste0("//xs:element[@name='", ., "']") %>%
    xml2::xml_find_all(x = xml2::read_xml("https://sms.bfs.admin.ch/WcfBFSSpecificService.svc?singleWsdl")) %>%
    checkmate::assert_list(len = 1L,
                           types = "xml_node",
                           any.missing = FALSE) %>%
    xml2::xml_find_all(xpath = ".//xs:element") %>%
    xml2::xml_attrs() %>%
    purrr::map(as.list) %>%
    purrr::map(tibble::as_tibble) %>%
    purrr::list_rbind()
}

parse_result <- function(response,
                         col_types) {
  
  response %<>% httr::content(as = "text")
  
  response %>% readr::read_csv(col_types = pal::cols_regex("(Name|_Title|_Text|^ABBREV)" = readr::col_character(),
                                                           "^(MutationDate|ValidFrom|ValidTo)$" = readr::col_date(format = "%d.%m.%Y"),
                                                           .col_names = pal::dsv_colnames(response),
                                                           .default = readr::col_integer()))
}

#' Get municipality snapshots
#'
#' Returns a [tibble][tibble::tbl_df] with snapshots of Swiss municipality data. A snapshot corresponds to the list of municipalities that are present at least
#' partially during the specified period (or at the specified day when `end_date = start_date`).
#'
#' @includeRmd snippets/fso_vs_historicized_code.Rmd
#'
#' @param start_date `r pkgsnip::param_label("start_date")`
#' @param end_date `r pkgsnip::param_label("end_date")`
#' @param historicized_code By default, the [_FSO commune number_](https://de.wikipedia.org/wiki/Gemeindenummer) is returned. Set to `TRUE` in order to get the
#'   _historicization number_ instead.
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param max_cache_age `r pkgsnip::param_label("max_cache_age")` Defaults to 1 day (24 hours).
#'
#' @return `r pkgsnip::return_label("data")`
#' @export
#'
#' @examples
#' swissmuni::snapshots(historicized_code = TRUE)
snapshots <- function(start_date = lubridate::today(),
                      end_date = start_date,
                      historicized_code = FALSE,
                      use_cache = TRUE,
                      max_cache_age = "1 day") {
  
  pkgpins::with_cache(expr = {
    
    httr::RETRY(verb = "GET",
                url = api_base_url,
                path = paste0(api_common_path, "snapshots"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             useBfsCode = tolower(checkmate::assert_flag(historicized_code))),
                times = 5L) %>%
      parse_result()
  },
  pkg = this_pkg,
  from_fn = "snapshots",
  start_date,
  end_date,
  historicized_code,
  use_cache = use_cache,
  max_cache_age = max_cache_age)
}

#' Get municipality congruences
#'
#' Returns a [tibble][tibble::tbl_df] with congruence data of Swiss municipalities. The data indicates for each existing municipality at the `start_date` to
#' which municipality/municipalities it corresponds at the `end_date`.
#'
#' @inheritParams snapshots
#' @param incl_unmodified Include municipalities where no changes occurred in the defined period.
#' @param incl_territory_exchange Include information (additional rows) about territory exchanges within and between municipalities.
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' swissmuni::congruences(start_date = lubridate::today(),
#'                        end_date = lubridate::today(),
#'                        max_cache_age = "6 hours")
congruences <- function(start_date = NULL,
                        end_date = NULL,
                        incl_unmodified = TRUE,
                        incl_territory_exchange = FALSE,
                        use_cache = TRUE,
                        max_cache_age = "1 day") {
  
  pkgpins::with_cache(expr = {
    
    httr::RETRY(verb = "GET",
                url = api_base_url,
                path = paste0(api_common_path, "correspondances"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             includeUnmodified = tolower(checkmate::assert_flag(incl_unmodified)),
                             includeTerritoryExchange = tolower(checkmate::assert_flag(incl_territory_exchange))),
                times = 5L) %>%
      parse_result()
  },
  pkg = this_pkg,
  from_fn = "congruences",
  start_date,
  end_date,
  incl_unmodified,
  incl_territory_exchange,
  use_cache = use_cache,
  max_cache_age = max_cache_age)
}

#' Get municipality mutations
#'
#' Returns a [tibble][tibble::tbl_df] with mutation data of Swiss municipalities. The data describes all changes related to the municipalities made between
#' `start_date` and `end_date`.
#'
#' @inheritParams snapshots
#' @inheritParams congruences
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' swissmuni::mutations(start_date = "2020-01-01",
#'                      end_date = "2020-06-30",
#'                      incl_territory_exchange = TRUE)
mutations <- function(start_date = NULL,
                      end_date = NULL,
                      incl_territory_exchange = FALSE,
                      use_cache = TRUE,
                      max_cache_age = "1 day") {
  
  pkgpins::with_cache(expr = {
    
    httr::RETRY(verb = "GET",
                url = api_base_url,
                path = paste0(api_common_path, "mutations"),
                query = list(startPeriod = as_api_date(start_date),
                             endPeriod = as_api_date(end_date),
                             includeTerritoryExchange = tolower(checkmate::assert_flag(incl_territory_exchange))),
                times = 5L) %>%
      parse_result()
  },
  pkg = this_pkg,
  from_fn = "mutations",
  start_date,
  end_date,
  incl_territory_exchange,
  use_cache = use_cache,
  max_cache_age = max_cache_age)
}

#' Get spatial classifications of municipalities
#'
#' Returns a [tibble][tibble::tbl_df] with a wide range of spatial classifications of Swiss municipalities, i.a. by language region, size of the municipality or
#' degree of agglomeration/urbanization.
#'
#' There are some classifications which have multiple column IDs (e.g. `HR_ARBREG2000_L2` and `HR_TYPMSR2000_L2` both contain the _spatial mobility regions_).
#' If `name_type` is set to a language code, column duplicates are given the name suffix "`r paste0(' (', cp_symbol, ')')`".
#'
#' @includeRmd snippets/fso_vs_historicized_code.Rmd
#'
#' @inheritParams snapshots
#' @param name_type The column name type to be returned. Defaults to the column IDs returned by the web service. If set to a language code, the columns
#'   starting with ID `HR_` will be named by its full label in the respective language instead.
#'
#' @inherit snapshots return
#' @export
#'
#' @examples
#' swissmuni::classifications(start_date = lubridate::today(),
#'                            end_date = lubridate::today(),
#'                            name_type = "de",
#'                            use_cache = FALSE)
classifications <- function(start_date = NULL,
                            end_date = NULL,
                            historicized_code = FALSE,
                            name_type = c("ID", "en", "de", "fr", "it"),
                            use_cache = TRUE,
                            max_cache_age = "1 day") {
  
  result <- pkgpins::with_cache(
    expr = {
      
      httr::RETRY(verb = "GET",
                  url = api_base_url,
                  path = paste0(api_common_path, "levels"),
                  query = list(startPeriod = as_api_date(start_date),
                               endPeriod = as_api_date(end_date),
                               useBfsCode = tolower(checkmate::assert_flag(historicized_code))),
                  times = 5L) %>%
        parse_result()
    },
    pkg = this_pkg,
    from_fn = "classifications",
    start_date,
    end_date,
    historicized_code,
    use_cache = use_cache,
    max_cache_age = max_cache_age
  )
  
  name_type <- rlang::arg_match(name_type)
  
  if (name_type != "ID") {
    
    hr_ix <- which(stringr::str_detect(colnames(result), "^HR_"))
    hr_ids <- colnames(result) %>% stringr::str_subset("^HR_")
    hr_names <- col_spec_classifications[[paste0("name_", name_type)]][match(hr_ids, col_spec_classifications$column_id)]
    
    # ensure column names are unique (there are different column IDs for the same values)
    # -> add the unicode symbol for copy/paste, multiple times if necessary
    while (anyDuplicated(hr_names)) {
      hr_names[which(duplicated(hr_names))] <- paste0(hr_names[which(duplicated(hr_names))], " ", cp_symbol)
    }
    
    colnames(result)[hr_ix] <- hr_names
  }
  
  result
}

#' `r this_pkg` package configuration metadata
#'
#' A [tibble][tibble::tbl_df] with metadata of all possible `r this_pkg` package configuration options. See [pal::pkg_config_val()] for more information.
#'
#' @format `r pkgsnip::return_label("data_cols", cols = colnames(pkg_config))`
#' @export
#'
#' @examples
#' swissmuni::pkg_config
"pkg_config"
